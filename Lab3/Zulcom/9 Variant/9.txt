
#include <fstream> // для работы с файлами: ifstream,ofstream
#include <iostream> // для работы с консолью: cin,cout
using namespace std; // используем стандартное пространство имен, в которм есть такие вещи как ifstrem, ofstream,cout,cin, пространство ios. 
/**
 *Функция averagePositive принимает массив и размер и возвращает среднее среди отрицательных чисел в этом массиве
 */
double averagePositive(int* array, int size)
{
	double sum = 0; // создадим счётчик сумм
	int counter = 0; // создадим счётчик количества элементов в сумме
	for(int i = 0; i < size; i++) // пробегаемся по этому массиву
		if(array[i]<0) // если текущий элемент меньше 0...
		{
			sum += array[i]; //... добавляем его в сумму и
			counter++; // увеличиваем счётчик на 1
		}
	return sum / counter; // возвращаем резульат деления суммы на количество - среднее арифметическое
}
/**
 * Функция printFronBin печатает на экран массив размером NxM из двоичного файла sample.bin
 */
void printFromBin()
{
	ifstream in("sample.bin", ios::binary); // открываем sample.bin на чтение используя поточный метод чтения из библиотеки fstream. То, что вывод будет именно двоичным, определяет флаг binary из пространства имён ios
	if(!in.is_open()) cout << "sample.bin cant open for read."; // если файл по каким-то причинам не открыт, выводим об этом сообщение.
	int N, M; // две переменных, в которых мы будем временно хранить размерность матрицы
	in.read(reinterpret_cast<char*>(&N), sizeof(N)); // чтение аналогично записи, так же приводим тип char к типу int используя стандартное приведение типов C++. см. комментарий стр.55
	in.read(reinterpret_cast<char*>(&M), sizeof(M));
	cout << N << " " << M << endl; // выводим на экран размерность
	int* ioBuffer = new int[M];// создадим массив размера M для хранения каждой строки из текстового файла
	for(int i = 0; i < N; i++) // бежим по строкам двоичного файла
	{
		in.read(reinterpret_cast<char*>(ioBuffer), sizeof(ioBuffer[0])*M); // залпом считываем целую строку из файла в наш временный массив
		for(int j = 0; j < M; j++) // теперь пробегаем по этому массиву и выводим каждый элемент через пробел
			cout << ioBuffer[j] << " ";
		cout << endl; // после каждой выведенной строки вставляем разрыв строки
	}
	delete[] ioBuffer; // очистим память временного массива
	in.close(); // закрываем поток чтения из двоичного файла
}
/**
 * Функция copytobin, принимает как аргумент массив, в который нужно записать размеры матрицы.
 *  Читает с текстового файла массив NxM и записывает в двоичный файл.
 */
void copyToBin(int* dementions)
{
	ifstream in("in.txt"); //открываем in.txt на чтение используя поточный метод чтения из библиотеки fstream.
	if(!in.is_open()) cout << "In.txt cant open"; // если файл по каким-то причинам не открыт, выводим об этом сообщение.
	int N, M; // две переменных, в которых мы будем временно хранить размерность матрицы
	in >> N >> M; // вводим их с файла
	dementions[0] = N; // записываем их в массив. Т.к массив мы передавали по адресу, возвращать его не надо - значения запишутся туда и с ними уже можно будет работать.
	dementions[1] = M;
	ofstream binOut("sample.bin", ios::binary); // открываем sample.bin на запись используя поточный метод записи из библиотеки fstream. То, что вывод будет именно двоичным, определяет флаг binary из пространства имён ios
	if(!binOut.is_open()) cout << "sample.bin cant open for write"; // если файл по каким-то причинам не открыт, выводим об этом сообщение.
	binOut.write(reinterpret_cast<char*>(&N), sizeof(N)); 
	/* Запись в файл. Поскольку в файле все переменные представляются как символы, мы должны привести тип int к символьному, для этого используем методы приведения C++ -- reinterpret_cast. Приводим к char, поэтому
	*  в косых скобках указан тип char*, в скобках передаем адрес int. Кроме того, для записи в двоичный файл нужно выделить в нём место определённого размера, поэтому мы используем функцию sizeof,
	*  которая возвращает размер объекта в байтах.
	*/
	binOut.write(reinterpret_cast<char*>(&M), sizeof(M));
	int* ioBuffer = new int[M]; // создадим массив размера M для хранения каждой строки из текстового файла
	for(int i = 0; i < N; i++) // пробегаемся по всем строкам
	{
		for(int j = 0; j < M; j++) // пробегаемся по всем столбцам
			in >> ioBuffer[j]; // запиываем  каждый элемент строки в наш временный массив
		binOut.write(reinterpret_cast<char*>(ioBuffer), sizeof(ioBuffer[0])*M); // теперь записываем всё это в двоичный файл. Трюк с размером состит в том, что в строке M чисел одинакового размера, поэтому достаточно взять размер
		// первого элемента и умножить его на количество элеентов в строке
	}
	delete[] ioBuffer; // очистим память временного массива
	in.close(); // закроем покток чтения из тектового файла
	binOut.close(); // закрываем поток записи в двоичный файл
}
/**
 * Функция getMatrixRow принимает номер строки, которую нужно получить из двоичного файла и размерность матрицы N и M. (чтобы лишний раз её не читать)
 */
int* getMatrixRow(int k, int N, int M)
{
	ifstream binIn("sample.bin", ios::binary);   // открываем sample.bin на чтение используя поточный метод чтения из библиотеки fstream. То, что вывод будет именно двоичным, определяет флаг binary из пространства имён ios
	if(!binIn.is_open()) cout << "sample.bin cant open for read"; // если файл по каким-то причинам не открыт, выводим об этом сообщение.
	binIn.seekg(sizeof(int) * 2, ios::beg); // перенесём указатель чтения так, чтобы не считывать размерность матрицы - пропустим 2*размер int байт с начала. То, что пропускать будем сначала, определяет флаг beg
	//( begin - начало на английском языке).
	int* row = new int[M]; // теперь создадим массив размером M, в котором будем хранить строку из матрицы.
	binIn.seekg(sizeof(int)*(2 + (k - 1) * M), ios::beg); // теперь перенесём указатель чтения на ту строку, которую нам нужно читать. Для этого умножим размер int на количетсво цифр,
	// содержищся в матрице до нужной нам строки. Обратите внимание на то, что K-1 потому, что пользователь вводит K подразумевая, что строки считаются с единицы, а в программе они считаются с нуля.
	binIn.read(reinterpret_cast<char*>(row), sizeof(row[0])*M); // считываем всю строку залпом в наш временный массив
	binIn.close(); // закрываем поток чтения с двоичного файла
	return row; // возвращаем заполненную строку
}
int main()
{
	int dementions[2]; // массив размерности матрицы. Именно массив, потому что нам нужно передавать два числа из функции, а функция может передавать только один объект.
	copyToBin(dementions); // вызов функции чтения из текстового файла и записи в двоичный. Параллельно в этой функции и запишем размерность в массив. 
	printFromBin(); // выводим на экран сождержимое двоичного файла
	int k; cin >> k; // создадим переменную K, в которой будем хранить номер строки, которую хочет обработать пользователь.
	int* kRow = getMatrixRow(k, dementions[0], dementions[1]); // теперь создадим массив, котоырй будет хранить эту строку и присвоим ей значение, которое вернёт функция getMatrixRow.
	cout << "Average of nagative values in row " << k << ": " << averagePositive(kRow, dementions[1]) <<endl; // выводим результаты вычислений из функции
	system("pause.exe"); // чтобы окно не закрывалось
	delete[] kRow; // удаляем память от К-й строки
	return 0; // функция main должна возвращать int, поэтому вернём 0
}